"""
Теоретическая оценка сложности алгоритма и затрат по памяти:

    Временная сложность:
        Мы проходим по списку посетителей и добавляем события для каждого заезда и отъезда, что занимает O(n), где n — количество посетителей.
        Затем мы сортируем события, что занимает O(m log m), где m — количество дней (событий). В худшем случае m = 2n, поэтому общая сложность будет O(n log n).

    Затраты по памяти:
        Мы используем дополнительную память для хранения событий, что составляет O(n) в худшем случае.

    Общие затраты по времени составляют O(n log n), а затраты по памяти составляют O(n).
"""


def max_visitors(dates):
    events = []  # Список для хранения событий (заезд и отъезд)

    # Преобразуем даты в события
    for check_in, check_out in dates:
        events.append((check_in, 1))  # Заезд
        events.append((check_out, -1))  # Отъезд

    # Сортируем события: сначала по дате, затем по типу события (заезд перед отъездом)
    events.sort(key=lambda x: (x[0], x[1]))

    current_visitors = 0  # Текущее количество посетителей
    max_visitors = 0  # Максимальное количество посетителей
    max_date = None  # Дата с максимальным количеством посетителей

    # Проходим по событиям
    for date, event in events:
        current_visitors += event  # Увеличиваем или уменьшаем количество посетителей

        # Проверяем, является ли текущее количество посетителей максимальным
        if current_visitors > max_visitors:
            max_visitors = current_visitors
            max_date = date

    return max_date, max_visitors  # Возвращаем дату и максимальное количество посетителей

# Пример использования
if __name__ == "__main__":
    visitors_dates = [("2024-09-15", "2024-09-15"), ("2024-09-14", "2024-09-21")]
    date, count = max_visitors(visitors_dates)
    print(f"Максимальное количество посетителей ({count}) было в день: {date}")
