"""
Теоретическая оценка сложности алгоритма и затрат по памяти:

    Временная сложность:
        Инициализация системы (конструктор `__init__`): O(d * n), где d — количество объектов, n — количество признаков. Мы вычисляем релевантность для каждого объекта.
        Метод `calculate_relevance`: O(n) для каждого объекта, вызывается d раз, что приводит к O(d * n).
        Метод `update_feature`: O(n) для обновления релевантности одного объекта.
        Метод `get_top_k_relevant`: O(d log d) для сортировки релевантностей и O(k) для получения первых k элементов.

   В общем, временная сложность алгоритма будет O(d * n + d log d) для получения релевантных объектов после инициализации.

    Затраты по памяти:
        Хранение признаков: O(d * n), где d — количество объектов, а n — количество признаков.
        Хранение релевантных оценок: O(d).
        Общая память: O(d * n + d) ля хранения признаков и O(d) для хранения оценок.
"""


class RelevanceSystem:
    def __init__(self, n, a, d, features):
        """Инициализация системы релевантности с заданными параметрами."""
        self.n = n  # Количество признаков
        self.a = a  # Вектор весов
        self.d = d  # Количество объектов
        self.features = features  # Признаки объектов
        # Инициализация оценок релевантности для каждого объекта
        self.relevance_scores = [self.calculate_relevance(i) for i in range(d)]

    def calculate_relevance(self, index):
        """Вычисляет релевантность объекта по его признакам и весам."""
        return sum(self.a[j] * self.features[index][j] for j in range(self.n))

    def update_feature(self, i, j, v):
        """Обновляет признак объекта и пересчитывает его релевантность."""
        self.features[i][j] = v  # Обновление значения признака
        self.relevance_scores[i] = self.calculate_relevance(i)  # Пересчет релевантности

    def get_top_k_relevant(self, k):
        """Возвращает индексы k самых релевантных объектов."""
        # Получаем индексы объектов, отсортированные по релевантности
        sorted_indices = sorted(range(self.d), key=lambda x: self.relevance_scores[x], reverse=True)
        return sorted_indices[:k]

# Пример использования
if __name__ == "__main__":
    # Входные данные
    n = 2  # Количество признаков
    a = [1, 100]  # Вектор весов
    d = 10  # Количество объектов
    features = [
        [1, 2],   # Признаки первого объекта
        [2, 1],   # Признаки второго объекта
        [3, 1],   # Признаки третьего объекта
        [4, 1],   # Признаки четвертого объекта
        [5, 1],   # Признаки пятого объекта
        [6, 1],   # Признаки шестого объекта
        [7, 1],   # Признаки седьмого объекта
        [8, 1],   # Признаки восьмого объекта
        [9, 1],   # Признаки девятого объекта
        [10, 1]   # Признаки десятого объекта
    ]
    q = 4  # Количество запросов
    queries = [
        "1 2",   # Запрос на получение 2 самых релевантных объектов
        "1 10",  # Запрос на получение 10 самых релевантных объектов
        "2 4 1 1000",  # Запрос на изменение признака
        "1 10"   # Запрос на получение 10 самых релевантных объектов после изменения
    ]

    # Создаем систему релевантности
    system = RelevanceSystem(n, a, d, features)

    # Обработка запросов
    output = []
    for query in queries:
        parts = list(map(int, query.split()))
        if parts[0] == 1:  # Запрос на получение k самых релевантных объектов
            k = parts[1]
            top_k_indices = system.get_top_k_relevant(k)
            output.append(" ".join(str(index + 1) for index in top_k_indices))  # +1 для 1-индексации
        elif parts[0] == 2:  # Запрос на изменение признака
            i = parts[1] - 1  # Приводим к 0-индексации
            j = parts[2] - 1  # Приводим к 0-индексации
            v = parts[3]
            system.update_feature(i, j, v)

    # Вывод результатов
    print("\n".join(output))

